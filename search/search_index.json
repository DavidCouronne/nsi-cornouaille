{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur NSI Cornouaille Ce site contient des ressources pour la sp\u00e9cialit\u00e9 Num\u00e9rique et Sciences Informatiques. Contenu du site Cours de Premi\u00e8re NSI Cours de Terminale NSI","title":"Accueil"},{"location":"#bienvenue-sur-nsi-cornouaille","text":"Ce site contient des ressources pour la sp\u00e9cialit\u00e9 Num\u00e9rique et Sciences Informatiques.","title":"Bienvenue sur NSI Cornouaille"},{"location":"#contenu-du-site","text":"Cours de Premi\u00e8re NSI Cours de Terminale NSI","title":"Contenu du site"},{"location":"premiere/","text":"Premi\u00e8re NSI Liens utiles http://nsi4noobs.fr/ Youtube - David Latouche - 1\u00e8re NSI","title":"Accueil"},{"location":"premiere/#premiere-nsi","text":"","title":"Premi\u00e8re NSI"},{"location":"premiere/#liens-utiles","text":"http://nsi4noobs.fr/ Youtube - David Latouche - 1\u00e8re NSI","title":"Liens utiles"},{"location":"premiere/algorithmique/introduction/","text":"Introduction \u00e0 l'algorithmique Info En g\u00e9n\u00e9ral, on \u00e9crit un programme informatique pour r\u00e9soudre un probl\u00e8me. Par exemple: comment d\u00e9terminer le plus court chemin pour aller d'une ville \u00e0 une autre rechercher l'adresse d'une personne dans un annuaire etc.. Pour ces probl\u00e8mes, il existe souvent plusieurs solutions. La science algorithmique permet des tester et de classer ces solutions. Notion d'algorithme D\u00e9finition Un algorithme est une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires ob\u00e9issant \u00e0 un enchainement d\u00e9termin\u00e9 et produisant un r\u00e9sultat souhait\u00e9. Les op\u00e9rations \u00e9l\u00e9mentaires dont il est question sont des op\u00e9rations r\u00e9alisables par un processeur, par exemple l'ajout, la suppression, la comparaison, etc... En g\u00e9n\u00e9ral, un algorithme travaille sur les donn\u00e9es d'entr\u00e9e et donne des donn\u00e9es de sortie. Propri\u00e9t\u00e9s et caract\u00e9ristiques d'un algortihme Propri\u00e9t\u00e9s d'un algorithme Un bon algorithme doit poss\u00e9der deux propri\u00e9t\u00e9s essentielles: Il doit se terminer : il ne doit pas \"tourner en rond\" ou continuer ind\u00e9finiment et il doit fournir le r\u00e9sultat en un nombre fini d'op\u00e9rations. Il doit \u00eatre correct : il doit produire le r\u00e9sultat attendu dans toutes les situations. Caract\u00e9ristiques d'un algorithme Un algorithme poss\u00e8de deux caract\u00e9ristiques: Son co\u00fbt en temps : le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son ex\u00e9cution, ou la dur\u00e9e de son ex\u00e9cution. Son co\u00fbt en espace : la quantit\u00e9 d'espace m\u00e9moire n\u00e9cessaire \u00e0 son ex\u00e9cution. Notion de complexit\u00e9 Info Dans le programme de sp\u00e9cialit\u00e9 NSI, on s'int\u00e9resse uniquement au co\u00fbt en temps d'un algorithme. Donald Knuth Le calcul de la complexit\u00e9 algorithmique (ou co\u00fbt algorithmique) est introduit en 1962 par Donald Knuth , informaticien et math\u00e9maticien am\u00e9ricain. C'est un indicateur de performance pertinent pour les algorithmes car il est ind\u00e9pendant de la machine utilis\u00e9e (microprocesseur, m\u00e9moire, ...) Notation grand O Lors de l'\u00e9tude d'un algorithme, on peut s'int\u00e9resser au cas simple, et au cas le plus d\u00e9favorable, appel\u00e9 le pire des cas . Dans le pire des cas, le co\u00fbt ou complexit\u00e9 de l'algorithme sera alors le plus \u00e9lev\u00e9 possible pour un m\u00eame algorithme. Le temps de calcul sera alors maximal. La notation \\(O\\) consiste \u00e0 majorer, par une fonction de r\u00e9f\u00e9rence, le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son d\u00e9roulement, pour \\(n\\) suffisamment grand. Quelques types de complexit\u00e9s Complexit\u00e9 constante: \\(O(1)\\) . Le co\u00fbt ne d\u00e9pend pas de la taille des donn\u00e9es. Complexit\u00e9 lin\u00e9aire: \\(O(n)\\) . Le co\u00fbt est proportionnel \u00e0 la taille des donn\u00e9es. Complexit\u00e9 quadratique: \\(O(n^2)\\) . Le co\u00fbt est proportionnel \u00e0 \\(n^2\\) . Complexit\u00e9 logarithmique: \\(O(log(n))\\) . Complexit\u00e9 exponentielle: \\(O(e^n)\\) .","title":"Introduction"},{"location":"premiere/algorithmique/introduction/#introduction-a-lalgorithmique","text":"Info En g\u00e9n\u00e9ral, on \u00e9crit un programme informatique pour r\u00e9soudre un probl\u00e8me. Par exemple: comment d\u00e9terminer le plus court chemin pour aller d'une ville \u00e0 une autre rechercher l'adresse d'une personne dans un annuaire etc.. Pour ces probl\u00e8mes, il existe souvent plusieurs solutions. La science algorithmique permet des tester et de classer ces solutions.","title":"Introduction \u00e0 l'algorithmique"},{"location":"premiere/algorithmique/introduction/#notion-dalgorithme","text":"D\u00e9finition Un algorithme est une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires ob\u00e9issant \u00e0 un enchainement d\u00e9termin\u00e9 et produisant un r\u00e9sultat souhait\u00e9. Les op\u00e9rations \u00e9l\u00e9mentaires dont il est question sont des op\u00e9rations r\u00e9alisables par un processeur, par exemple l'ajout, la suppression, la comparaison, etc... En g\u00e9n\u00e9ral, un algorithme travaille sur les donn\u00e9es d'entr\u00e9e et donne des donn\u00e9es de sortie.","title":"Notion d'algorithme"},{"location":"premiere/algorithmique/introduction/#proprietes-et-caracteristiques-dun-algortihme","text":"Propri\u00e9t\u00e9s d'un algorithme Un bon algorithme doit poss\u00e9der deux propri\u00e9t\u00e9s essentielles: Il doit se terminer : il ne doit pas \"tourner en rond\" ou continuer ind\u00e9finiment et il doit fournir le r\u00e9sultat en un nombre fini d'op\u00e9rations. Il doit \u00eatre correct : il doit produire le r\u00e9sultat attendu dans toutes les situations. Caract\u00e9ristiques d'un algorithme Un algorithme poss\u00e8de deux caract\u00e9ristiques: Son co\u00fbt en temps : le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son ex\u00e9cution, ou la dur\u00e9e de son ex\u00e9cution. Son co\u00fbt en espace : la quantit\u00e9 d'espace m\u00e9moire n\u00e9cessaire \u00e0 son ex\u00e9cution.","title":"Propri\u00e9t\u00e9s et caract\u00e9ristiques d'un algortihme"},{"location":"premiere/algorithmique/introduction/#notion-de-complexite","text":"Info Dans le programme de sp\u00e9cialit\u00e9 NSI, on s'int\u00e9resse uniquement au co\u00fbt en temps d'un algorithme. Donald Knuth Le calcul de la complexit\u00e9 algorithmique (ou co\u00fbt algorithmique) est introduit en 1962 par Donald Knuth , informaticien et math\u00e9maticien am\u00e9ricain. C'est un indicateur de performance pertinent pour les algorithmes car il est ind\u00e9pendant de la machine utilis\u00e9e (microprocesseur, m\u00e9moire, ...) Notation grand O Lors de l'\u00e9tude d'un algorithme, on peut s'int\u00e9resser au cas simple, et au cas le plus d\u00e9favorable, appel\u00e9 le pire des cas . Dans le pire des cas, le co\u00fbt ou complexit\u00e9 de l'algorithme sera alors le plus \u00e9lev\u00e9 possible pour un m\u00eame algorithme. Le temps de calcul sera alors maximal. La notation \\(O\\) consiste \u00e0 majorer, par une fonction de r\u00e9f\u00e9rence, le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son d\u00e9roulement, pour \\(n\\) suffisamment grand. Quelques types de complexit\u00e9s Complexit\u00e9 constante: \\(O(1)\\) . Le co\u00fbt ne d\u00e9pend pas de la taille des donn\u00e9es. Complexit\u00e9 lin\u00e9aire: \\(O(n)\\) . Le co\u00fbt est proportionnel \u00e0 la taille des donn\u00e9es. Complexit\u00e9 quadratique: \\(O(n^2)\\) . Le co\u00fbt est proportionnel \u00e0 \\(n^2\\) . Complexit\u00e9 logarithmique: \\(O(log(n))\\) . Complexit\u00e9 exponentielle: \\(O(e^n)\\) .","title":"Notion de complexit\u00e9"},{"location":"premiere/algorithmique/parcours/","text":"Algorithmes de parcours Info On s'int\u00e9resse \u00e0 un tableau not\u00e9 tab et contenant \\(n\\) \u00e9l\u00e9ments not\u00e9s tab[i] pour \\(0 \\leq i < n\\) . On suppose que les \u00e9l\u00e9ments du tableau sont des nombres. Comptage d'une occurence Parcours total Le parcours total est par exemple mis en oeuvre lors d'un comptage d'occurences . La boucle \"pour\" est alors \u00e0 privil\u00e9gier. On cherche combien de fois un \u00e9l\u00e9ment not\u00e9 b apparait dans le tableau tab . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. def compte_occurences ( tab , b ): \"\"\"In: une liste tab et un nombre b. Out: le nombre d'occurences de b\"\"\" if tab == []: # on teste si le tableau est vide return 0 compteur = 0 # On initialise le compteur \u00e0 0 for elem in tab : # boucle de parcours total if elem == b : # si l'\u00e9l\u00e9ment courant est \u00e9gal \u00e0 l'\u00e9l\u00e9ment cherch\u00e9 compteur = compteur + 1 # on incr\u00e9mente le compteur return compteur Complexit\u00e9 du parcours total Le tableau est parcouru dans sa totalit\u00e9 dans tous les cas. Le nombre d'\u00e9tapes est donc proportionnel \u00e0 la taille du tableau. On a une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) . Recherche d'une occurence Parcours partiel Le parcours partiel est par exemple mis en oeuvre lors d'une recherche d'occurence . La boucle \"tant que\" est alors \u00e0 privil\u00e9gier. On cherche si le tableau tab contient un \u00e9l\u00e9ment not\u00e9 b . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. Il renvoie True si b est dans le tableau et False sinon. def recherche_occurence ( tab , b ): \"\"\"In: tab une liste de nombres et b un nombre. Out: True si b appartient \u00e0 la liste et False sinon\"\"\" if tab == []: # on teste si le tableau est vide return False i = 0 # On initialise le parcours \u00e0 l'indice 0 trouve = False # On initialise le bool\u00e9en trouve \u00e0 False while i < len ( tab ) and not trouve : # boucle de parcours if tab [ i ] == b : # si l'\u00e9l\u00e9ment d'indice i est l'\u00e9l\u00e9ment recherch\u00e9 trouve = True # trouve devient vrai else : # sinon on continue le parcours i = i + 1 return trouve Complexit\u00e9 du parcours partiel La complexit\u00e9 d'un parcours partiel d\u00e9pend de la structure de donn\u00e9es parcourue. Le concept de pire des cas et de meilleur des cas prend tout son sens avec ce type de parcours. Dans le meilleur des cas , l'\u00e9l\u00e9ment cherch\u00e9 sera trouv\u00e9 d\u00e8s le d\u00e9but de la recherche. L'algorithme s'arr\u00e8te au bout d'une \u00e9tape. Dans le pire des cas , l'\u00e9l\u00e9ment cherch\u00e9 est absent de la structure de donn\u00e9es et le parcours sera total. On a donc une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) . Recherche d'un maximum ou d'un minimum Parcours total Le parcours total est n\u00e9cessaire pour trouver la valeur maximale (ou minimale) d'une structure de donn\u00e9es. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Le programme suivant est une impl\u00e9mentation possible. def maximum ( tab ): \"\"\"In: tab une liste de nombres Out: le maximum de la liste\"\"\" if tab == []: return 'erreur' # si le tableau est vide on renvoie 'erreur' maxi = tab [ 0 ] # on initialise le maxi comme le 1er \u00e9l\u00e9ment for i in range ( 1 , len ( tab )): # boucle de parcours total if tab [ i ] > maxi : maxi = tab [ i ] return maxi Calcul de la moyenne Parcours total Pour calculer la moyenne , la relation suivante est indispensable: \\[\\text{moyenne} = \\frac{\\text{somme des \u00e9l\u00e9ments}}{\\text{nombre d'\u00e9l\u00e9ments}}\\] Le parcours total est donc n\u00e9cessaire et une variable temporaire sera utilis\u00e9e pour stocker la somme de tous les \u00e9l\u00e9ments rencontr\u00e9s au fil du parcours. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Info L'algorithme de calcul d'une moyenne est ressemble \u00e0 l'algorithme de comptage d'occurences. def moyenne ( tab ): \"\"\"In: tab une liste de nombres Out: la moyenne \"\"\" if tab == []: return 'erreur' somme = 0 for elem in tab : somme = somme + elem return somme / len ( tab )","title":"Parcours s\u00e9quentiels"},{"location":"premiere/algorithmique/parcours/#algorithmes-de-parcours","text":"Info On s'int\u00e9resse \u00e0 un tableau not\u00e9 tab et contenant \\(n\\) \u00e9l\u00e9ments not\u00e9s tab[i] pour \\(0 \\leq i < n\\) . On suppose que les \u00e9l\u00e9ments du tableau sont des nombres.","title":"Algorithmes de parcours"},{"location":"premiere/algorithmique/parcours/#comptage-dune-occurence","text":"Parcours total Le parcours total est par exemple mis en oeuvre lors d'un comptage d'occurences . La boucle \"pour\" est alors \u00e0 privil\u00e9gier. On cherche combien de fois un \u00e9l\u00e9ment not\u00e9 b apparait dans le tableau tab . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. def compte_occurences ( tab , b ): \"\"\"In: une liste tab et un nombre b. Out: le nombre d'occurences de b\"\"\" if tab == []: # on teste si le tableau est vide return 0 compteur = 0 # On initialise le compteur \u00e0 0 for elem in tab : # boucle de parcours total if elem == b : # si l'\u00e9l\u00e9ment courant est \u00e9gal \u00e0 l'\u00e9l\u00e9ment cherch\u00e9 compteur = compteur + 1 # on incr\u00e9mente le compteur return compteur Complexit\u00e9 du parcours total Le tableau est parcouru dans sa totalit\u00e9 dans tous les cas. Le nombre d'\u00e9tapes est donc proportionnel \u00e0 la taille du tableau. On a une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) .","title":"Comptage d'une occurence"},{"location":"premiere/algorithmique/parcours/#recherche-dune-occurence","text":"Parcours partiel Le parcours partiel est par exemple mis en oeuvre lors d'une recherche d'occurence . La boucle \"tant que\" est alors \u00e0 privil\u00e9gier. On cherche si le tableau tab contient un \u00e9l\u00e9ment not\u00e9 b . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. Il renvoie True si b est dans le tableau et False sinon. def recherche_occurence ( tab , b ): \"\"\"In: tab une liste de nombres et b un nombre. Out: True si b appartient \u00e0 la liste et False sinon\"\"\" if tab == []: # on teste si le tableau est vide return False i = 0 # On initialise le parcours \u00e0 l'indice 0 trouve = False # On initialise le bool\u00e9en trouve \u00e0 False while i < len ( tab ) and not trouve : # boucle de parcours if tab [ i ] == b : # si l'\u00e9l\u00e9ment d'indice i est l'\u00e9l\u00e9ment recherch\u00e9 trouve = True # trouve devient vrai else : # sinon on continue le parcours i = i + 1 return trouve Complexit\u00e9 du parcours partiel La complexit\u00e9 d'un parcours partiel d\u00e9pend de la structure de donn\u00e9es parcourue. Le concept de pire des cas et de meilleur des cas prend tout son sens avec ce type de parcours. Dans le meilleur des cas , l'\u00e9l\u00e9ment cherch\u00e9 sera trouv\u00e9 d\u00e8s le d\u00e9but de la recherche. L'algorithme s'arr\u00e8te au bout d'une \u00e9tape. Dans le pire des cas , l'\u00e9l\u00e9ment cherch\u00e9 est absent de la structure de donn\u00e9es et le parcours sera total. On a donc une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) .","title":"Recherche d'une occurence"},{"location":"premiere/algorithmique/parcours/#recherche-dun-maximum-ou-dun-minimum","text":"Parcours total Le parcours total est n\u00e9cessaire pour trouver la valeur maximale (ou minimale) d'une structure de donn\u00e9es. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Le programme suivant est une impl\u00e9mentation possible. def maximum ( tab ): \"\"\"In: tab une liste de nombres Out: le maximum de la liste\"\"\" if tab == []: return 'erreur' # si le tableau est vide on renvoie 'erreur' maxi = tab [ 0 ] # on initialise le maxi comme le 1er \u00e9l\u00e9ment for i in range ( 1 , len ( tab )): # boucle de parcours total if tab [ i ] > maxi : maxi = tab [ i ] return maxi","title":"Recherche d'un maximum ou d'un minimum"},{"location":"premiere/algorithmique/parcours/#calcul-de-la-moyenne","text":"Parcours total Pour calculer la moyenne , la relation suivante est indispensable: \\[\\text{moyenne} = \\frac{\\text{somme des \u00e9l\u00e9ments}}{\\text{nombre d'\u00e9l\u00e9ments}}\\] Le parcours total est donc n\u00e9cessaire et une variable temporaire sera utilis\u00e9e pour stocker la somme de tous les \u00e9l\u00e9ments rencontr\u00e9s au fil du parcours. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Info L'algorithme de calcul d'une moyenne est ressemble \u00e0 l'algorithme de comptage d'occurences. def moyenne ( tab ): \"\"\"In: tab une liste de nombres Out: la moyenne \"\"\" if tab == []: return 'erreur' somme = 0 for elem in tab : somme = somme + elem return somme / len ( tab )","title":"Calcul de la moyenne"},{"location":"premiere/types_construits/dictionnaires/","text":"Les dictionnaires en Python D\u00e9finition d'un dictionnaire en Python Dictionnaire Un dictionnaire est une collection non ordonn\u00e9e d'\u00e9l\u00e9ments. Ces \u00e9l\u00e9ments sont constitu\u00e9s d'une cl\u00e9 associ\u00e9e \u00e0 une valeur . Cl\u00e9s Les cl\u00e9s peuvent \u00eatre de n'importe quel type non-mutable : entier, cha\u00eene de caract\u00e8re, p-uplet. Cr\u00e9ation d'un dictionnaire en Python Cr\u00e9ation d'un dictionnaire Un nouveau dictionnaire est cr\u00e9\u00e9 par affectation et n\u00e9cessite l'utilisation d' accolades , ce qui la diff\u00e9rencie des listes et des p-iplet. Une valeur est associ\u00e9e \u00e0 une cl\u00e9 selon la syntaxe cl\u00e9: valeur Exemple: annuaire = { 10 : 'Paul' , 20 : 'Tom' , 30 : 'Nadia' } Dans cet exemple, les cl\u00e9s sont des entiers: 10, 20, 30. La valeur associ\u00e9e \u00e0 la cl\u00e9 20 est: 'Tom' Dictionnaire vide Le dictionnaire vide est {} Acc\u00e8s aux \u00e9l\u00e9ments d'un dictionnaire en Python Acc\u00e8s grace aux cl\u00e9s Les \u00e9l\u00e9ments du dictionnaire ne sont pas index\u00e9s. On acc\u00e8de \u00e0 une valeur grace \u00e0 la cl\u00e9 qui lui est associ\u00e9e. Danger Les cl\u00e9s d'un dictionnaire doivent \u00eatre toutes diff\u00e9rentes . Exemple: # On imagine un panier de fruits contenant # 2 pommes, 2 oranges, 3 fraises et 1 banane panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'pomme' ] # 2 panier [ 'fraise' ] # 3 Modification du dictionnaire en Python Mutable Un dictionnaire est un objet mutable . Exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'banane' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 5} Ajout d'une cl\u00e9 On peut ajouter une cl\u00e9 dans un dictionnaire Par exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'kiwi' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 1, 'kiwi': 5} M\u00e9thodes sp\u00e9cifiques sur les dictionnaires en Python La m\u00e9thode items() La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode items() for elem in panier . items (): # (1) print ( elem ) # ('pomme', 2) # ('orange', 2) # ('fraise', 3) # ('banane', 1) La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. La m\u00e9thode keys() La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode keys() for cle in panier . keys (): # (1) print ( cle ) # 'pomme' # 'orange' # 'fraise' # 'banane' La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. La m\u00e9thode keys() La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode values() for valeur in panier . values (): # (1) print ( valeur ) # 2 # 2 # 3 # 1 La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire. Exemples d'utilisation. Scripts Python Test d'appartenance d'une cl\u00e9: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } 'pomme' in panier # True 'kiwi' in panier # False Affichage format\u00e9: # Affichage des cl\u00e9s et des valeurs for cle in panier . keys (): # (1) print ( f \"J'ai { panier [ cle ] } { cle } (s) dans mon panier.\" ) La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. Affichage: J 'ai 2 pomme(s) dans mon panier. J' ai 2 orange ( s ) dans mon panier. J 'ai 3 fraise(s) dans mon panier. J' ai 1 banane ( s ) dans mon panier.","title":"Les dictionnaires"},{"location":"premiere/types_construits/dictionnaires/#les-dictionnaires-en-python","text":"","title":"Les dictionnaires en Python"},{"location":"premiere/types_construits/dictionnaires/#definition-dun-dictionnaire-en-python","text":"Dictionnaire Un dictionnaire est une collection non ordonn\u00e9e d'\u00e9l\u00e9ments. Ces \u00e9l\u00e9ments sont constitu\u00e9s d'une cl\u00e9 associ\u00e9e \u00e0 une valeur . Cl\u00e9s Les cl\u00e9s peuvent \u00eatre de n'importe quel type non-mutable : entier, cha\u00eene de caract\u00e8re, p-uplet.","title":"D\u00e9finition d'un dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#creation-dun-dictionnaire-en-python","text":"Cr\u00e9ation d'un dictionnaire Un nouveau dictionnaire est cr\u00e9\u00e9 par affectation et n\u00e9cessite l'utilisation d' accolades , ce qui la diff\u00e9rencie des listes et des p-iplet. Une valeur est associ\u00e9e \u00e0 une cl\u00e9 selon la syntaxe cl\u00e9: valeur Exemple: annuaire = { 10 : 'Paul' , 20 : 'Tom' , 30 : 'Nadia' } Dans cet exemple, les cl\u00e9s sont des entiers: 10, 20, 30. La valeur associ\u00e9e \u00e0 la cl\u00e9 20 est: 'Tom' Dictionnaire vide Le dictionnaire vide est {}","title":"Cr\u00e9ation d'un dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#acces-aux-elements-dun-dictionnaire-en-python","text":"Acc\u00e8s grace aux cl\u00e9s Les \u00e9l\u00e9ments du dictionnaire ne sont pas index\u00e9s. On acc\u00e8de \u00e0 une valeur grace \u00e0 la cl\u00e9 qui lui est associ\u00e9e. Danger Les cl\u00e9s d'un dictionnaire doivent \u00eatre toutes diff\u00e9rentes . Exemple: # On imagine un panier de fruits contenant # 2 pommes, 2 oranges, 3 fraises et 1 banane panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'pomme' ] # 2 panier [ 'fraise' ] # 3","title":"Acc\u00e8s aux \u00e9l\u00e9ments d'un dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#modification-du-dictionnaire-en-python","text":"Mutable Un dictionnaire est un objet mutable . Exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'banane' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 5} Ajout d'une cl\u00e9 On peut ajouter une cl\u00e9 dans un dictionnaire Par exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'kiwi' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 1, 'kiwi': 5}","title":"Modification du dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#methodes-specifiques-sur-les-dictionnaires-en-python","text":"La m\u00e9thode items() La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode items() for elem in panier . items (): # (1) print ( elem ) # ('pomme', 2) # ('orange', 2) # ('fraise', 3) # ('banane', 1) La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. La m\u00e9thode keys() La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode keys() for cle in panier . keys (): # (1) print ( cle ) # 'pomme' # 'orange' # 'fraise' # 'banane' La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. La m\u00e9thode keys() La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode values() for valeur in panier . values (): # (1) print ( valeur ) # 2 # 2 # 3 # 1 La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire.","title":"M\u00e9thodes sp\u00e9cifiques sur les dictionnaires en Python"},{"location":"premiere/types_construits/dictionnaires/#exemples-dutilisation-scripts-python","text":"Test d'appartenance d'une cl\u00e9: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } 'pomme' in panier # True 'kiwi' in panier # False Affichage format\u00e9: # Affichage des cl\u00e9s et des valeurs for cle in panier . keys (): # (1) print ( f \"J'ai { panier [ cle ] } { cle } (s) dans mon panier.\" ) La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. Affichage: J 'ai 2 pomme(s) dans mon panier. J' ai 2 orange ( s ) dans mon panier. J 'ai 3 fraise(s) dans mon panier. J' ai 1 banane ( s ) dans mon panier.","title":"Exemples d'utilisation. Scripts Python"},{"location":"premiere/types_construits/listes/","text":"Listes en Python D\u00e9finition des listes en Python D\u00e9finition Tableau : Un tableau est une collection ordonn\u00e9e d'\u00e9l\u00e9ments de n'importe quel type, organis\u00e9s s\u00e9quentiellement les uns \u00e0 la suite des autres. Info En Python, un tableau est appel\u00e9 liste . Il est de type list Le tableau est modifiable par affectation, on dit qu'il est mutable Bases sur les listes en Python Cr\u00e9ation d'une liste Dans une liste, tous les termes doivent \u00eatre s\u00e9par\u00e9s par des virgules et entour\u00e9s de crochets Exemple L = [ 1 , 5 , 8 ] Info Une liste peut aussi contenir des \u00e9l\u00e9ments de types diff\u00e9rents lst = [ 4 , \"bonjour\" , False , [ 7 , 9 ]] liste vide La liste vide est not\u00e9e [] lst = [] # liste vide Acc\u00e8s aux \u00e9l\u00e9ments d'une liste en Python Acc\u00e9der aux \u00e9l\u00e9ments d'une liste On acc\u00e8de \u00e0 un \u00e9l\u00e9ment d'une liste en mettant entre crochets l'indice de l'\u00e9l\u00e9m\u00e9nt (qui commence \u00e0 z\u00e9ro ). Exemple >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 0 ] 'Bart' >>> famille [ 1 ] 'Lisa' >>> famille [ 2 ] 'Maggie' Danger Un indice qui d\u00e9passe la valeur longueur de la liste -1 provoquera une erreur list index out of range . Exemple: >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 3 ] # Erreur de type list index out of range IndexError : list index out of range Indices n\u00e9gatifs Il est possible d'utiliser des indices n\u00e9gatifs . \\(-1\\) correspond alors au dernier \u00e9l\u00e9ment de la liste. Exemple d'utilisation d'indices n\u00e9gatifs >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ - 1 ] 'Maggie' >>> famille [ - 2 ] 'Lisa' Modification d'une liste par affectation en Python Modification d'une liste Les termes d'une listes peuvent \u00eatre modifi\u00e9s par affectation au cours d'un programme. Cela est possible car les listes sont des objets mutables . Exemple de modification par affectation >>> animaux = [ 'renards' , 'crocodiles' , 'z\u00e8bres' ] >>> animaux [ 1 ] = 'toucans' >>> print ( animaux ) [ 'renards' , 'toucans' , 'z\u00e8bres' ] Longueur d'une liste en Python Longueur d'une liste La longueur d'une liste sera donn\u00e9e par la fonction len() Exemple >>> lst = [ 3 , 'bonjour' , True , [ 1 , 2 , 5 ]] >>> len ( lst ) 4 Test d'appartenance avec in en Python Tester l'appartenance d'un \u00e9l\u00e9ment dans une liste On peut tester si un \u00e9l\u00e9ment appartient \u00e0 une liste avec in Example de test d'appartenance >>> lst = [ 'n' , 's' , 'i' ] >>> print ( 'n' in lst ) True >>> print ( 'b' in lst ) False Op\u00e9ration sur les listes en Python La m\u00e9thode append() Les listes Python ont la particularit\u00e9 de pouvoir \u00eatre allong\u00e9es d'un \u00e9l\u00e9ment en fin de liste, gr\u00e2ce \u00e0 la m\u00e9thode append() Example d'utilisation de la m\u00e9thode append() >>> felins = [ 'chats' , 'tigres' , 'l\u00e9opards' ] >>> felins . append ( 'lions' ) >>> print ( felins ) [ 'chats' , 'tigres' , 'l\u00e9opards' , 'lions' ] La concat\u00e9nation Avec l'op\u00e9rateur + , on peut concat\u00e9ner deux listes, c'est-\u00e0-dire cr\u00e9er une nouvelle liste form\u00e9e avec deux listes. Exemple de concat\u00e9nation >>> lst1 = [ 3 , 5 , 7 ] >>> lst2 = [ 12 , 15 , 9 ] >>> lst3 = lst1 + lst2 >>> print ( lst3 ) [ 3 , 5 , 7 , 12 , 15 , 9 ] Multiplication par un entier On peut utiliser la multiplication par un entier int pour dupliquer une liste. Exemple de multiplication par un entier >>> lst1 = [ 0 ] * 5 >>> print ( lst1 ) [ 0 , 0 , 0 , 0 , 0 ] >>> lst2 = [ 't' , 'u' ] * 3 >>> print ( lst2 ) [ 't' , 'u' , 't' , 'u' , 't' , 'u' ] Le slicing en Python Le slicing Le d\u00e9coupage de liste (appel\u00e9 slicing ) permet d'extraire un s\u00e9quence d'une liste. Soit lst une liste La syntaxe lst[i:j] permet d'extraire de la liste tous les \u00e9l\u00e9ments cons\u00e9cutifs compris entre l'\u00e9l\u00e9ment de rang i inclus et l'\u00e9l\u00e9ment de rang j exclus . Exemples de slicing >>> jours = [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Les deux premiers jours de la semaine >>> jours [ 0 : 2 ] [ 'lundi' , 'mardi' ] ## On peut omettre le 0 >>> jours [: 2 ] [ 'lundi' , 'mardi' ] ## Du mardi au vendredi >>> jours [ 1 : 5 ] [ 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' ] ## Du jeudi jusqu'\u00e0 la fin >>> jours [ 3 :] [ 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Tout sauf le dimanche >>> jours [: - 1 ] [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' ] Info Dans le cas du slicing, il n'y a pas d'erreur d'indexation. Par exemple: >>> lst = [ 1 , 2 , 3 ] >>> lst [ 2021 :] [] Liste en compr\u00e9hension en Python Info Il est possible et \u00e9l\u00e9gant de construire une liste en compr\u00e9hension avec le langage Python. C'est tr\u00e8s pratique pour cr\u00e9er, transformer ou filtrer une liste. Exemples de listes en compr\u00e9hension >>> nombres = [ k for k in range ( 10 )] >>> nombres [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] Il est bien s\u00fbr possible d'agir sur le param\u00e8tre : >>> carres_parfaits = [ k ** 2 for k in range ( 10 )] >>> carres_parfaits [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Filtrage Ajouter une condition de filtrage permet de ne s\u00e9lectionner que certains \u00e9l\u00e9ments de la liste. Exemples de filtrages >>> c = [ n for n in carres_parfaits if n % 3 == 0 ] >>> c [ 0 , 9 , 36 , 81 ] Matrices: les listes de listes en Python Cr\u00e9ation d'une liste de listes Un tableau \u00e0 double entr\u00e9e, appel\u00e9 matrice , peut \u00eatre repr\u00e9sent\u00e9 par une liste de listes. Exemples de matrices .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0lax{text-align:left;vertical-align:top} 7 9 5 2 L = [[ 7 , 9 ], [ 5 , 2 ]] On peut aussi \u00e9crire sur plusieurs lignes pour plus de confort visuel: L = [[ 7 , 9 ], [ 5 , 2 ]] Exemple du jeu de morpion On peut repr\u00e9senter ce tableau par une liste de listes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Bien s\u00fbr on peut mettre sur plusieurs lignes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Convention sur les lignes et les colonnes Par convention, les lignes sont not\u00e9es avec l'indice \\(i\\) et les colonnes sont not\u00e9es avec \\(j\\) . Exemples d'acc\u00e8s aux \u00e9l\u00e9ments des matrices morpion [ i ][ j ] # ligne d'indice i, colonne d'indice j morpion [ 0 ][ 0 ] # ligne 1, colonne 1 morpion [ 0 ][ 0 ] # 'X' morpion [ 2 ][ 1 ] # 'O' morpion [ 1 ][ 2 ] # ' ' On suppose que le joueur 'X' veuille emp\u00eacher le joueur 'O' de gagner: morpion [ 2 ][ 2 ] = 'X' # morpion = [['X', ' ', ' '], # ['X', ' ', ' '], # ['O', 'O', 'X']] Matrices en compr\u00e9hension On peut g\u00e9n\u00e9rer des matrices en compr\u00e9hension Exemple de matrice en compr\u00e9hension >>> matrice = [[ i + j for j in range ( 3 )] for i in range ( 3 )] >>> matrice [[ 0 , 1 , 2 ], [ 1 , 2 , 3 ], [ 2 , 3 , 4 ]]","title":"Les listes"},{"location":"premiere/types_construits/listes/#listes-en-python","text":"","title":"Listes en Python"},{"location":"premiere/types_construits/listes/#definition-des-listes-en-python","text":"D\u00e9finition Tableau : Un tableau est une collection ordonn\u00e9e d'\u00e9l\u00e9ments de n'importe quel type, organis\u00e9s s\u00e9quentiellement les uns \u00e0 la suite des autres. Info En Python, un tableau est appel\u00e9 liste . Il est de type list Le tableau est modifiable par affectation, on dit qu'il est mutable","title":"D\u00e9finition des listes en Python"},{"location":"premiere/types_construits/listes/#bases-sur-les-listes-en-python","text":"Cr\u00e9ation d'une liste Dans une liste, tous les termes doivent \u00eatre s\u00e9par\u00e9s par des virgules et entour\u00e9s de crochets Exemple L = [ 1 , 5 , 8 ] Info Une liste peut aussi contenir des \u00e9l\u00e9ments de types diff\u00e9rents lst = [ 4 , \"bonjour\" , False , [ 7 , 9 ]] liste vide La liste vide est not\u00e9e [] lst = [] # liste vide","title":"Bases sur les listes en Python"},{"location":"premiere/types_construits/listes/#acces-aux-elements-dune-liste-en-python","text":"Acc\u00e9der aux \u00e9l\u00e9ments d'une liste On acc\u00e8de \u00e0 un \u00e9l\u00e9ment d'une liste en mettant entre crochets l'indice de l'\u00e9l\u00e9m\u00e9nt (qui commence \u00e0 z\u00e9ro ). Exemple >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 0 ] 'Bart' >>> famille [ 1 ] 'Lisa' >>> famille [ 2 ] 'Maggie' Danger Un indice qui d\u00e9passe la valeur longueur de la liste -1 provoquera une erreur list index out of range . Exemple: >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 3 ] # Erreur de type list index out of range IndexError : list index out of range Indices n\u00e9gatifs Il est possible d'utiliser des indices n\u00e9gatifs . \\(-1\\) correspond alors au dernier \u00e9l\u00e9ment de la liste. Exemple d'utilisation d'indices n\u00e9gatifs >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ - 1 ] 'Maggie' >>> famille [ - 2 ] 'Lisa'","title":"Acc\u00e8s aux \u00e9l\u00e9ments d'une liste en Python"},{"location":"premiere/types_construits/listes/#modification-dune-liste-par-affectation-en-python","text":"Modification d'une liste Les termes d'une listes peuvent \u00eatre modifi\u00e9s par affectation au cours d'un programme. Cela est possible car les listes sont des objets mutables . Exemple de modification par affectation >>> animaux = [ 'renards' , 'crocodiles' , 'z\u00e8bres' ] >>> animaux [ 1 ] = 'toucans' >>> print ( animaux ) [ 'renards' , 'toucans' , 'z\u00e8bres' ]","title":"Modification d'une liste par affectation en Python"},{"location":"premiere/types_construits/listes/#longueur-dune-liste-en-python","text":"Longueur d'une liste La longueur d'une liste sera donn\u00e9e par la fonction len() Exemple >>> lst = [ 3 , 'bonjour' , True , [ 1 , 2 , 5 ]] >>> len ( lst ) 4","title":"Longueur d'une liste en Python"},{"location":"premiere/types_construits/listes/#test-dappartenance-avec-in-en-python","text":"Tester l'appartenance d'un \u00e9l\u00e9ment dans une liste On peut tester si un \u00e9l\u00e9ment appartient \u00e0 une liste avec in Example de test d'appartenance >>> lst = [ 'n' , 's' , 'i' ] >>> print ( 'n' in lst ) True >>> print ( 'b' in lst ) False","title":"Test d'appartenance avec in en Python"},{"location":"premiere/types_construits/listes/#operation-sur-les-listes-en-python","text":"La m\u00e9thode append() Les listes Python ont la particularit\u00e9 de pouvoir \u00eatre allong\u00e9es d'un \u00e9l\u00e9ment en fin de liste, gr\u00e2ce \u00e0 la m\u00e9thode append() Example d'utilisation de la m\u00e9thode append() >>> felins = [ 'chats' , 'tigres' , 'l\u00e9opards' ] >>> felins . append ( 'lions' ) >>> print ( felins ) [ 'chats' , 'tigres' , 'l\u00e9opards' , 'lions' ] La concat\u00e9nation Avec l'op\u00e9rateur + , on peut concat\u00e9ner deux listes, c'est-\u00e0-dire cr\u00e9er une nouvelle liste form\u00e9e avec deux listes. Exemple de concat\u00e9nation >>> lst1 = [ 3 , 5 , 7 ] >>> lst2 = [ 12 , 15 , 9 ] >>> lst3 = lst1 + lst2 >>> print ( lst3 ) [ 3 , 5 , 7 , 12 , 15 , 9 ] Multiplication par un entier On peut utiliser la multiplication par un entier int pour dupliquer une liste. Exemple de multiplication par un entier >>> lst1 = [ 0 ] * 5 >>> print ( lst1 ) [ 0 , 0 , 0 , 0 , 0 ] >>> lst2 = [ 't' , 'u' ] * 3 >>> print ( lst2 ) [ 't' , 'u' , 't' , 'u' , 't' , 'u' ]","title":"Op\u00e9ration sur les listes en Python"},{"location":"premiere/types_construits/listes/#le-slicing-en-python","text":"Le slicing Le d\u00e9coupage de liste (appel\u00e9 slicing ) permet d'extraire un s\u00e9quence d'une liste. Soit lst une liste La syntaxe lst[i:j] permet d'extraire de la liste tous les \u00e9l\u00e9ments cons\u00e9cutifs compris entre l'\u00e9l\u00e9ment de rang i inclus et l'\u00e9l\u00e9ment de rang j exclus . Exemples de slicing >>> jours = [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Les deux premiers jours de la semaine >>> jours [ 0 : 2 ] [ 'lundi' , 'mardi' ] ## On peut omettre le 0 >>> jours [: 2 ] [ 'lundi' , 'mardi' ] ## Du mardi au vendredi >>> jours [ 1 : 5 ] [ 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' ] ## Du jeudi jusqu'\u00e0 la fin >>> jours [ 3 :] [ 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Tout sauf le dimanche >>> jours [: - 1 ] [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' ] Info Dans le cas du slicing, il n'y a pas d'erreur d'indexation. Par exemple: >>> lst = [ 1 , 2 , 3 ] >>> lst [ 2021 :] []","title":"Le slicing en Python"},{"location":"premiere/types_construits/listes/#liste-en-comprehension-en-python","text":"Info Il est possible et \u00e9l\u00e9gant de construire une liste en compr\u00e9hension avec le langage Python. C'est tr\u00e8s pratique pour cr\u00e9er, transformer ou filtrer une liste. Exemples de listes en compr\u00e9hension >>> nombres = [ k for k in range ( 10 )] >>> nombres [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] Il est bien s\u00fbr possible d'agir sur le param\u00e8tre : >>> carres_parfaits = [ k ** 2 for k in range ( 10 )] >>> carres_parfaits [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Filtrage Ajouter une condition de filtrage permet de ne s\u00e9lectionner que certains \u00e9l\u00e9ments de la liste. Exemples de filtrages >>> c = [ n for n in carres_parfaits if n % 3 == 0 ] >>> c [ 0 , 9 , 36 , 81 ]","title":"Liste en compr\u00e9hension en Python"},{"location":"premiere/types_construits/listes/#matrices-les-listes-de-listes-en-python","text":"Cr\u00e9ation d'une liste de listes Un tableau \u00e0 double entr\u00e9e, appel\u00e9 matrice , peut \u00eatre repr\u00e9sent\u00e9 par une liste de listes. Exemples de matrices .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0lax{text-align:left;vertical-align:top} 7 9 5 2 L = [[ 7 , 9 ], [ 5 , 2 ]] On peut aussi \u00e9crire sur plusieurs lignes pour plus de confort visuel: L = [[ 7 , 9 ], [ 5 , 2 ]] Exemple du jeu de morpion On peut repr\u00e9senter ce tableau par une liste de listes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Bien s\u00fbr on peut mettre sur plusieurs lignes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Convention sur les lignes et les colonnes Par convention, les lignes sont not\u00e9es avec l'indice \\(i\\) et les colonnes sont not\u00e9es avec \\(j\\) . Exemples d'acc\u00e8s aux \u00e9l\u00e9ments des matrices morpion [ i ][ j ] # ligne d'indice i, colonne d'indice j morpion [ 0 ][ 0 ] # ligne 1, colonne 1 morpion [ 0 ][ 0 ] # 'X' morpion [ 2 ][ 1 ] # 'O' morpion [ 1 ][ 2 ] # ' ' On suppose que le joueur 'X' veuille emp\u00eacher le joueur 'O' de gagner: morpion [ 2 ][ 2 ] = 'X' # morpion = [['X', ' ', ' '], # ['X', ' ', ' '], # ['O', 'O', 'X']] Matrices en compr\u00e9hension On peut g\u00e9n\u00e9rer des matrices en compr\u00e9hension Exemple de matrice en compr\u00e9hension >>> matrice = [[ i + j for j in range ( 3 )] for i in range ( 3 )] >>> matrice [[ 0 , 1 , 2 ], [ 1 , 2 , 3 ], [ 2 , 3 , 4 ]]","title":"Matrices: les listes de listes en Python"},{"location":"premiere/types_construits/tuple/","text":"Les p-uplet en Python D\u00e9finition des tuple en Python p-uplet Un p-uplet (ou tuple en anglais) est une collection ordonn\u00e9e d'\u00e9l\u00e9ments, appel\u00e9s composantes ou termes . Chaque terme peut \u00eatre de n'importe quel type. tuple Le p-uplet est de type tuple . non mutable Les termes du p-uplet ne sont pas modifiables par affectation. Un tuple est non-mutable Cr\u00e9ation d'un p-uplet en Python Cr\u00e9ation d'un tuple En langage Python, les termes d'un p-uplet sont s\u00e9par\u00e9s par des virgules. Les parenth\u00e8ses ne sont pas obligatoires mais sont fortement conseill\u00e9es pour la lisibilit\u00e9 du code. Exemples t = ( 1 , 8 , 5 ) print ( type ( t )) # <class 'tuple'> # ou bien, mais fortement d\u00e9conseill\u00e9. # Mis ici en exemple car cela arrive dans certains codes... t = 1 , 8 , 5 tuple vide Le tuple vide est (, ) Indexation des \u00e9l\u00e9ments du p-uplet en Python Indexation L'indexation fonctionne exactement comme avec les listes. pointA = ( 3 , - 4 ) pointA [ 0 ] # 3 pointA [ 1 ] # -4 Modification d'un p-uplet en Python Danger Il n'est pas possible de modifier par affectation les termes d'un p-uplet apr\u00e8s sa cr\u00e9ation. Un p-uplet est dit non-mutable Exemple t = ( 1 , 2 , 8 ) t [ 0 ] = 12 # TypeError: 'tuple' object does not support item assignment Fonction renvoyant un p-uplet de valeurs en Python En programmation fonctionnelle, il est indispensable d'utiliser des fonctions pouvant renvoyer un ensemble de valeurs r\u00e9utilisables, contenus dans un p-uplet ou une liste. Par exemple, on souhaite calculer les coordonn\u00e9es du milieu I d'un segment [AB]: def milieu ( A , B ): xI = ( A [ 0 ] + B [ 0 ]) / 2 yI = ( A [ 1 ] + B [ 1 ]) / 2 return ( xI , yI ) A = ( 2 , 1 ) B = ( 3 , 5 ) I = milieu ( A , B ) print ( I ) # (2.5, 3.0)","title":"Les tuple"},{"location":"premiere/types_construits/tuple/#les-p-uplet-en-python","text":"","title":"Les p-uplet en Python"},{"location":"premiere/types_construits/tuple/#definition-des-tuple-en-python","text":"p-uplet Un p-uplet (ou tuple en anglais) est une collection ordonn\u00e9e d'\u00e9l\u00e9ments, appel\u00e9s composantes ou termes . Chaque terme peut \u00eatre de n'importe quel type. tuple Le p-uplet est de type tuple . non mutable Les termes du p-uplet ne sont pas modifiables par affectation. Un tuple est non-mutable","title":"D\u00e9finition des tuple en Python"},{"location":"premiere/types_construits/tuple/#creation-dun-p-uplet-en-python","text":"Cr\u00e9ation d'un tuple En langage Python, les termes d'un p-uplet sont s\u00e9par\u00e9s par des virgules. Les parenth\u00e8ses ne sont pas obligatoires mais sont fortement conseill\u00e9es pour la lisibilit\u00e9 du code. Exemples t = ( 1 , 8 , 5 ) print ( type ( t )) # <class 'tuple'> # ou bien, mais fortement d\u00e9conseill\u00e9. # Mis ici en exemple car cela arrive dans certains codes... t = 1 , 8 , 5 tuple vide Le tuple vide est (, )","title":"Cr\u00e9ation d'un p-uplet en Python"},{"location":"premiere/types_construits/tuple/#indexation-des-elements-du-p-uplet-en-python","text":"Indexation L'indexation fonctionne exactement comme avec les listes. pointA = ( 3 , - 4 ) pointA [ 0 ] # 3 pointA [ 1 ] # -4","title":"Indexation des \u00e9l\u00e9ments du p-uplet en Python"},{"location":"premiere/types_construits/tuple/#modification-dun-p-uplet-en-python","text":"Danger Il n'est pas possible de modifier par affectation les termes d'un p-uplet apr\u00e8s sa cr\u00e9ation. Un p-uplet est dit non-mutable Exemple t = ( 1 , 2 , 8 ) t [ 0 ] = 12 # TypeError: 'tuple' object does not support item assignment","title":"Modification d'un p-uplet en Python"},{"location":"premiere/types_construits/tuple/#fonction-renvoyant-un-p-uplet-de-valeurs-en-python","text":"En programmation fonctionnelle, il est indispensable d'utiliser des fonctions pouvant renvoyer un ensemble de valeurs r\u00e9utilisables, contenus dans un p-uplet ou une liste. Par exemple, on souhaite calculer les coordonn\u00e9es du milieu I d'un segment [AB]: def milieu ( A , B ): xI = ( A [ 0 ] + B [ 0 ]) / 2 yI = ( A [ 1 ] + B [ 1 ]) / 2 return ( xI , yI ) A = ( 2 , 1 ) B = ( 3 , 5 ) I = milieu ( A , B ) print ( I ) # (2.5, 3.0)","title":"Fonction renvoyant un p-uplet de valeurs en Python"},{"location":"terminales/","text":"Terminales NSI Lien utile: https://glassus.github.io/terminale_nsi/","title":"Introduction"},{"location":"terminales/#terminales-nsi","text":"Lien utile: https://glassus.github.io/terminale_nsi/","title":"Terminales NSI"},{"location":"terminales/sujets_pratiques/BSN_2022/","text":"\u00c9preuve Pratique BNS 2022 \u00c0 lire Les sujets correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 .","title":"Banque de sujets 2022"},{"location":"terminales/sujets_pratiques/BSN_2022/#epreuve-pratique-bns-2022","text":"\u00c0 lire Les sujets correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 .","title":"\u00c9preuve Pratique BNS 2022"},{"location":"terminales/sujets_pratiques/sujet1/","text":"Sujet NSI 2022 - Sujet 1 Exercice 1 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction def recherche ( caractere , mot ): occurence = 0 for elem in mot : if elem == caractere : occurence += 1 return occurence assert recherche ( 'e' , \"sciences\" ) == 2 assert recherche ( 'i' , \"mississippi\" ) == 4 assert recherche ( 'a' , \"mississippi\" ) == 0 Exercice 2 On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Correction Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = Pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) assert rendu_glouton ( 68 , [], 0 ) == [ 50 , 10 , 5 , 2 , 1 ] assert rendu_glouton ( 291 , [], 0 ) == [ 100 , 100 , 50 , 20 , 20 , 1 ]","title":"Sujet 1"},{"location":"terminales/sujets_pratiques/sujet1/#sujet-nsi-2022-sujet-1","text":"","title":"Sujet NSI 2022 - Sujet 1"},{"location":"terminales/sujets_pratiques/sujet1/#exercice-1","text":"\u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction def recherche ( caractere , mot ): occurence = 0 for elem in mot : if elem == caractere : occurence += 1 return occurence assert recherche ( 'e' , \"sciences\" ) == 2 assert recherche ( 'i' , \"mississippi\" ) == 4 assert recherche ( 'a' , \"mississippi\" ) == 0","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet1/#exercice-2","text":"On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Correction Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = Pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) assert rendu_glouton ( 68 , [], 0 ) == [ 50 , 10 , 5 , 2 , 1 ] assert rendu_glouton ( 291 , [], 0 ) == [ 100 , 100 , 50 , 20 , 20 , 1 ]","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet11/","text":"Sujet NSI 2022 - Sujet 11 Exercice 1 \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, \\(-1\\) sinon. Exemples: >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Correction def recherche ( tab , n ): debut = 0 fin = len ( tab ) - 1 while debut < fin : milieu = ( debut + fin ) // 2 valeur_centrale = tab [ milieu ] if valeur_centrale == n : return milieu elif valeur_centrale > n : fin = milieu - 1 else : debut = milieu + 1 return - 1 assert recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) == 3 assert recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) == - 1 Exercice 2 Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Correction ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat assert cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' assert cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'","title":"Sujet 11"},{"location":"terminales/sujets_pratiques/sujet11/#sujet-nsi-2022-sujet-11","text":"","title":"Sujet NSI 2022 - Sujet 11"},{"location":"terminales/sujets_pratiques/sujet11/#exercice-1","text":"\u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, \\(-1\\) sinon. Exemples: >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Correction def recherche ( tab , n ): debut = 0 fin = len ( tab ) - 1 while debut < fin : milieu = ( debut + fin ) // 2 valeur_centrale = tab [ milieu ] if valeur_centrale == n : return milieu elif valeur_centrale > n : fin = milieu - 1 else : debut = milieu + 1 return - 1 assert recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) == 3 assert recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) == - 1","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet11/#exercice-2","text":"Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Correction ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat assert cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' assert cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet2/","text":"Sujet NSI 2022 - Sujet 2 Exercice 1 Exercice 1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs Exercice 2 Exercice 2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C","title":"Sujet 2"},{"location":"terminales/sujets_pratiques/sujet2/#sujet-nsi-2022-sujet-2","text":"","title":"Sujet NSI 2022 - Sujet 2"},{"location":"terminales/sujets_pratiques/sujet2/#exercice-1","text":"Exercice 1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet2/#exercice-2","text":"Exercice 2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet23/","text":"Sujet NSI 2022 - 23 Exercice 1 (4 points) Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : { 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 } \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) Exercice 2 (4 points) Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2+3)\u00d75. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3\u00d72+5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. A la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\" Renvoie le bool\u00e9en True si la pile est vide, False sinon. \"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l\u2019\u00e9l\u00e9ment v au sommet de la pile.\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ...","title":"Sujet 23"},{"location":"terminales/sujets_pratiques/sujet23/#sujet-nsi-2022-23","text":"","title":"Sujet NSI 2022 - 23"},{"location":"terminales/sujets_pratiques/sujet23/#exercice-1-4-points","text":"Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : { 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 } \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 )","title":"Exercice 1 (4 points)"},{"location":"terminales/sujets_pratiques/sujet23/#exercice-2-4-points","text":"Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2+3)\u00d75. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3\u00d72+5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. A la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\" Renvoie le bool\u00e9en True si la pile est vide, False sinon. \"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l\u2019\u00e9l\u00e9ment v au sommet de la pile.\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ...","title":"Exercice 2 (4 points)"},{"location":"terminales/sujets_pratiques/sujet3/","text":"Sujet NSI 2022 - Sujet 3 Exercice 1 Exercice 03.1 \u00c9nonc\u00e9 Correction Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff Exercice 2 Exercice 03.2 \u00c9nonc\u00e9 Correction Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s ```","title":"Sujet 3"},{"location":"terminales/sujets_pratiques/sujet3/#sujet-nsi-2022-sujet-3","text":"","title":"Sujet NSI 2022 - Sujet 3"},{"location":"terminales/sujets_pratiques/sujet3/#exercice-1","text":"Exercice 03.1 \u00c9nonc\u00e9 Correction Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet3/#exercice-2","text":"Exercice 03.2 \u00c9nonc\u00e9 Correction Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s ```","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet4/","text":"Sujet NSI 2022 - Sujet 4 Exercice 1 Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution Exercice 2 Exercice 04.2 \u00c9nonc\u00e9 Correction Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val )","title":"Sujet 4"},{"location":"terminales/sujets_pratiques/sujet4/#sujet-nsi-2022-sujet-4","text":"","title":"Sujet NSI 2022 - Sujet 4"},{"location":"terminales/sujets_pratiques/sujet4/#exercice-1","text":"Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet4/#exercice-2","text":"Exercice 04.2 \u00c9nonc\u00e9 Correction Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val )","title":"Exercice 2"}]}